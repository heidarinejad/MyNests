import numpy
import pylab
import nest

pop1=nest.Create("iaf_psc_alpha", 10)
pop2=nest.Create("iaf_psc_alpha", 10)
nest.SetStatus(pop1, {"I_e" : 376.0})
multimeter=nest.Create("multimeter",10)
nest.SetStatus(multimeter, {"withtime":True, "record_from": ["V_m"]})

#first default method of connection is all_to_all method
nest.Connect(pop1,pop2, syn_spec={"weight":20.0})     # 100 connection

# or one_to_one method
nest.Connect(pop1,pop2,"one_to_one", syn_spec={"weight":20.0, "delay":1.0})

# and then connection of multimeter
nest.Connect(multimeter, pop2)

# another way is the random connections
# there is 4 methods for random connectivity

d=1.0
Je=2.0
Ke=20
Ji=-4.0
Ki=12

# if we want ke connection for each neuron in target pop of ipop1
# fixed_indegree method
conn_dict_ex={"rule": "fixed_indegree","indegree": Ke}
conn_dict_in={"rule": "fixed_indegree","indegree": Ki}
syn_dict_ex={"delay": d, "weight":Je}
syn_dict_in={"delay": d, "weight":Ji}

nest.Connect(epop1, ipop1, conn_dict_ex, syn_dict_ex)    # each neuron in ipop1 group receives randomly Ke connection from epop1
nest.Connect(ipop1, epop1, conn_dict_in, syn_dict_in)    # each neuron in epop1 group receives randomly Ki connection from ipop1

# fixed_outdegree method
# this method randomly choose n taget neuron from post pop for each neuron in pre pop.
# using indegree method is more recommended than outdegree

# fixed_total_number method
# n random connection between pre and post population       # how many connection per each neuron???


# pairwise_bernoulli method
# connection are generated by iterating through all possible source-target pairs and creating each connection with probability p


# in addition to above 4 methods "autapases" and "multpases" could set to "False" & "True"
# self_connection and multiple_connection between two neuron